

# New LazyFrame from CSV

## Description

Read a file from path into a polars LazyFrame.

## Usage

<pre><code class='language-R'>pl_scan_csv(
  source,
  ...,
  has_header = TRUE,
  separator = ",",
  comment_prefix = NULL,
  quote_char = "\"",
  skip_rows = 0,
  dtypes = NULL,
  null_values = NULL,
  ignore_errors = FALSE,
  cache = FALSE,
  infer_schema_length = 100,
  n_rows = NULL,
  encoding = "utf8",
  low_memory = FALSE,
  rechunk = TRUE,
  skip_rows_after_header = 0,
  row_index_name = NULL,
  row_index_offset = 0,
  try_parse_dates = FALSE,
  eol_char = "\n",
  raise_if_empty = TRUE,
  truncate_ragged_lines = FALSE,
  reuse_downloaded = TRUE
)
</code></pre>

## Arguments

<table>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="source">source</code>
</td>
<td>
Path to a file or URL. It is possible to provide multiple paths provided
that all CSV files have the same schema. It is not possible to provide
several URLs.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="...">…</code>
</td>
<td>
Ignored.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="has_header">has_header</code>
</td>
<td>
Indicate if the first row of dataset is a header or not.If
<code>FALSE</code>, column names will be autogenerated in the following
format: <code>“column_x”</code> <code>x</code> being an enumeration over
every column in the dataset starting at 1.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="separator">separator</code>
</td>
<td>
Single byte character to use as separator in the file.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="comment_prefix">comment_prefix</code>
</td>
<td>
A string, which can be up to 5 symbols in length, used to indicate the
start of a comment line. For instance, it can be set to
<code style="white-space: pre;">\#</code> or
<code style="white-space: pre;">//</code>.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="quote_char">quote_char</code>
</td>
<td>
Single byte character used for quoting. Set to <code>NULL</code> to turn
off special handling and escaping of quotes.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="skip_rows">skip_rows</code>
</td>
<td>
Start reading after a particular number of rows. The header will be
parsed at this offset.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="dtypes">dtypes</code>
</td>
<td>

Named list of column names - dtypes or dtype - column names. This list
is used while reading to overwrite dtypes. Supported types so far are:

<ul>
<li>

"Boolean" or "logical" for DataType::Boolean,

</li>
<li>

"Categorical" or "factor" for DataType::Categorical,

</li>
<li>

"Float32" or "double" for DataType::Float32,

</li>
<li>

"Float64" or "float64" for DataType::Float64,

</li>
<li>

"Int32" or "integer" for DataType::Int32,

</li>
<li>

"Int64" or "integer64" for DataType::Int64,

</li>
<li>

"String" or "character" for DataType::String,

</li>
</ul>
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="null_values">null_values</code>
</td>
<td>

Values to interpret as <code>NA</code> values. Can be:

<ul>
<li>

a character vector: all values that match one of the values in this
vector will be <code>NA</code>;

</li>
<li>

a named list with column names and null values.

</li>
</ul>
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="ignore_errors">ignore_errors</code>
</td>
<td>
Keep reading the file even if some lines yield errors. You can also use
<code>infer_schema_length = 0</code> to read all columns as UTF8 to
check which values might cause an issue.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="cache">cache</code>
</td>
<td>
Cache the result after reading.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="infer_schema_length">infer_schema_length</code>
</td>
<td>
Maximum number of rows to read to infer the column types. If set to 0,
all columns will be read as UTF-8. If <code>NULL</code>, a full table
scan will be done (slow).
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="n_rows">n_rows</code>
</td>
<td>
Maximum number of rows to read.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="encoding">encoding</code>
</td>
<td>
Either <code>“utf8”</code> or <code>“utf8-lossy”</code>. Lossy means
that invalid UTF8 values are replaced with "?" characters.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="low_memory">low_memory</code>
</td>
<td>
Reduce memory usage (will yield a lower performance).
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="rechunk">rechunk</code>
</td>
<td>
Reallocate to contiguous memory when all chunks / files are parsed.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="skip_rows_after_header">skip_rows_after_header</code>
</td>
<td>
Parse the first row as headers, and then skip this number of rows.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="row_index_name">row_index_name</code>
</td>
<td>
If not <code>NULL</code>, this will insert a row index column with the
given name into the DataFrame.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="row_index_offset">row_index_offset</code>
</td>
<td>
Offset to start the row index column (only used if the name is set).
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="try_parse_dates">try_parse_dates</code>
</td>
<td>
Try to automatically parse dates. Most ISO8601-like formats can be
inferred, as well as a handful of others. If this does not succeed, the
column remains of data type <code>pl$String</code>.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="eol_char">eol_char</code>
</td>
<td>
Single byte end of line character (default:
<code style="white-space: pre;"></code>). When encountering a file with
Windows line endings (<code style="white-space: pre;"></code>), one can
go with the default <code style="white-space: pre;"></code>. The extra
<code style="white-space: pre;">/code\> will be removed when processed.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="raise_if_empty">raise_if_empty</code>
</td>
<td>
If <code>FALSE</code>, parsing an empty file returns an empty DataFrame
or LazyFrame.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="truncate_ragged_lines">truncate_ragged_lines</code>
</td>
<td>
Truncate lines that are longer than the schema.
</td>
</tr>
<tr>
<td style="white-space: nowrap; font-family: monospace; vertical-align: top">
<code id="reuse_downloaded">reuse_downloaded</code>
</td>
<td>
If <code>TRUE</code>(default) and a URL was provided, cache the
downloaded files in session for an easy reuse.
</td>
</tr>
</table>

## Value

LazyFrame

## Examples

``` r
library(polars)

my_file = tempfile()
write.csv(iris, my_file)
lazy_frame = pl$scan_csv(my_file)
lazy_frame$collect()
```

    #> shape: (150, 6)
    #> ┌─────┬──────────────┬─────────────┬──────────────┬─────────────┬───────────┐
    #> │     ┆ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species   │
    #> │ --- ┆ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---       │
    #> │ i64 ┆ f64          ┆ f64         ┆ f64          ┆ f64         ┆ str       │
    #> ╞═════╪══════════════╪═════════════╪══════════════╪═════════════╪═══════════╡
    #> │ 1   ┆ 5.1          ┆ 3.5         ┆ 1.4          ┆ 0.2         ┆ setosa    │
    #> │ 2   ┆ 4.9          ┆ 3.0         ┆ 1.4          ┆ 0.2         ┆ setosa    │
    #> │ 3   ┆ 4.7          ┆ 3.2         ┆ 1.3          ┆ 0.2         ┆ setosa    │
    #> │ 4   ┆ 4.6          ┆ 3.1         ┆ 1.5          ┆ 0.2         ┆ setosa    │
    #> │ 5   ┆ 5.0          ┆ 3.6         ┆ 1.4          ┆ 0.2         ┆ setosa    │
    #> │ …   ┆ …            ┆ …           ┆ …            ┆ …           ┆ …         │
    #> │ 146 ┆ 6.7          ┆ 3.0         ┆ 5.2          ┆ 2.3         ┆ virginica │
    #> │ 147 ┆ 6.3          ┆ 2.5         ┆ 5.0          ┆ 1.9         ┆ virginica │
    #> │ 148 ┆ 6.5          ┆ 3.0         ┆ 5.2          ┆ 2.0         ┆ virginica │
    #> │ 149 ┆ 6.2          ┆ 3.4         ┆ 5.4          ┆ 2.3         ┆ virginica │
    #> │ 150 ┆ 5.9          ┆ 3.0         ┆ 5.1          ┆ 1.8         ┆ virginica │
    #> └─────┴──────────────┴─────────────┴──────────────┴─────────────┴───────────┘

``` r
unlink(my_file)
```
